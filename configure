#! /usr/local/bin/bash

#
# This file is *NOT* generated by GNU Autoconf, but written by NIIBE Yutaka
#
# Copyright (C) 2013, 2015 Free Software Initiative of Japan
#
# This file is a part of Frawcheky, the GPL container.
#
# Fraucheky is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# Fraucheky is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

##########################################################
# Build operating system detection and portability support
#
# This script uses somewhat non-portable utility named 'stat'
# to get mata information of files.
#
# Since the command line syntax of stat depends on operating system,
# this script detects the operating system at the initialization, and
# use the function get_size_and_timestamp which changes its behavior
# with $OS variable.
#
# Global variable OS will have the operating system detected.
#
# Currently, only GNU and OTHER is supported, where OTHER means
# FreeBSD or Mac OS X.

function check_build_operating_system {
    local os
    os=$(uname -o 2>/dev/null)

    if [[ $? -eq 0 && "$os" =~ ^GNU ]]; then
	# -o option of uname command is not POSIX-compliant.
        # It is (only) available on GNU system.
	# If it accepts -o option and the string starts with "GNU",
	# It must be GNU operating system which respects users' freedom.
	OS=GNU
    else
	OS=OTHER
    fi
}

function get_size_and_timestamp {
    local filename=$1

    if [ "$OS" = GNU ]; then
	stat -L -c '%s %X %Y %Z' $filename
    else
	stat -L -f '%z %a %m %c' $filename
    fi
}
##########################################################


check_build_operating_system

THIS_SCRIPT=$0
DIR=$(dirname $THIS_SCRIPT)

vidpid=$1
with_index=$2
REVISION=$3
REVISION_CHOPSTX=$4
REVISION_FRAUCHEKY=$5

# Copy INDEX file.
if test "$with_index" = "none"; then
  echo "Please specify INDEX file by --with-index=<INDEX> option." 
  exit 1
else
  sed -e "s%@REVISION@%$REVISION%" -e "s%@REVISION_CHOPSTX@%$REVISION_CHOPSTX%"\
      -e "s%@REVISION_FRAUCHEKY@%$REVISION_FRAUCHEKY%" $with_index > INDEX
fi

# Copy GPL if not.
if ! test -f COPYING; then
   cp -p $DIR/COPYING .
fi

# Copy README file.
if ! test -f README; then
   cp -p ../README .
fi

###############################
clusterstart=2

TZ=UTC

let parity=0 cls=$clusterstart endmark=0 newline=0
BLOCKS_LIST=""

function output_two_clusters {
    local v=$(($1+$2*4096))
    local hexv="$(printf "%06x" ${v})"
    echo -n ' ' 0x${hexv:4:2}, 0x${hexv:2:1}${hexv:3:1}, 0x${hexv:0:2},
    if ((newline++ == 3)); then
	newline=0
	echo ' \'
    fi
}

function ding {
    local cls0=$cls cls1=$((++cls))
    if !((parity^=1)); then
	if ((endmark==0)); then
	    output_two_clusters $cls0 $cls1
	else
	    output_two_clusters 4095 $cls1
	    endmark=0
	fi
    fi
}

function dong {
    local cls0=$cls cls1=$((++cls))

    if !((parity^=1)); then
	output_two_clusters $cls0 4095
	endmark=0
	if ((newline!=0)); then
	    newline=0
	    echo ' \'
	fi
    else
	endmark=1
    fi
}

function dongdong {
    if ((parity)); then
	output_two_clusters 4095 0
	echo ' \'
    fi
}


function car {
    echo $1
}

function cdr {
    shift 1
    echo $*
}

function cluster_map {
    dong
    local i
    echo "#define CLUSTER_MAP \\"
    for filename in $*; do
	i="$(car $BLOCKS_LIST)"
	BLOCKS_LIST=$(cdr $BLOCKS_LIST)
	if ((newline!=0)); then
	    newline=0
	    echo
	fi
	echo "  /* $filename: $i sectors */ \\"
	while true; do
	    if  !((--i)); then
		dong
		break
	    else
		ding
	    fi
	done
    done
    dongdong
    echo '  /* END */'
}

function fat_datetime_sub {
    let d=$((($2-1980)*512+$3*32+$4)) t=$(($5*2048+$6*32+$7/2)) f=$(($7%2*100))

    case $1 in
	-d) # date only
	    echo $d
	;;
	-t) # time included
	    echo $d $t
	;;
	-f) # full (date, time, and 10ms fine-resolution)
	    echo $d $t $f
	;;
    esac
}

# input: option (full/datetime/date), POSIX time (second from Epoch)
# output: FAT datetime in hex
function fat_datetime {
    local datetime="$(printf '%(%Y %_m %_d %_H %_M %_S)T' $2)"

    fat_datetime_sub $1 $datetime
}

function two_byte_in_hex {
    printf "0x%02x, 0x%02x" $(($1%256)) $(($1/256))
}

function four_byte_in_hex {
    two_byte_in_hex $2
    echo -n ", "
    two_byte_in_hex $1
}

function five_byte_in_hex {
    printf "0x%02x, " $3
    two_byte_in_hex $2
    echo -n ", "
    two_byte_in_hex $1
}

function output_file_param {
    local create_time=$(($4<$5?$4:$5)) blocks=$((($2+511)/512))

    echo "#define $1_FILE_SIZE  $(four_byte_in_hex $(($2/65536)) $(($2%65536)))"
    echo "#define $1_BLOCKS $blocks"
    echo "#define $1_ATTRIBUTES                        \\"
    echo '  0x21,                         /* Archive, Read only */  \'
    echo '  0x00,                                                   \'
    echo "  $(five_byte_in_hex $(fat_datetime -f $create_time)), /* Create */              \\"
    echo "  $(two_byte_in_hex $(fat_datetime -d $3)),                   /* Access */              \\"
    echo '  0x00, 0x00,                   /* Access-right bitmap */ \' 
    echo "  $(four_byte_in_hex $(fat_datetime -t $4))        /* Modified */"
    echo
    BLOCKS_LIST="$BLOCKS_LIST $blocks"
}

function file_info {
    for filename in $*; do
	output_file_param $filename $(get_size_and_timestamp $filename)
    done
}

FILES="COPYING README INDEX"

exec > disk-on-rom.h

file_info $FILES
cluster_map $FILES

# $ stat -c '%s %X %Y %Z' /usr/share/common-licenses/GPL-3
# 35147 1415190442 1183330535 1415190442
#
#        %X     time of last access, seconds since Epoch
#        %Y     time of last data modification, seconds since Epoch
#        %Z     time of last status change, seconds since Epoch
#
# 1970-01-01 00:00:00 UTC = 0
# 1980-01-01 00:00:00 UTC = 315532800

# time in FAT is localtime, we assume that build and use with UTC.

# TZ=UTC printf '%(%Y %m %d %H %M %S)T\n' 315532800 
# 1980 01 01 00 00 00
